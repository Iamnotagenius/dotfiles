#!/usr/bin/env bash

build_name_filter() {
    local -n out=$1
    local mode=$2
    shift 2
    out=('(')
    for name in "$@"; do
        case "$mode" in
            prefix)
                out+=(-name "$(printf '%q\n' "$name")*" -or)
                ;;
            suffix)
                out+=(-name "*$(printf '%q\n' "$name")" -or)
                ;;
            *)
                echo "Unrecognized filter mode."
                exit 1
        esac
    done
    out[${#out[@]}-1]=')'
}

BASE_DIR=~/Videos
OUTPUT_DIR=/tmp/merged

VIDEO_EXTENSIONS=(.mkv)
video_name_args=()
build_name_filter video_name_args suffix "${VIDEO_EXTENSIONS[@]}"

SUBDUB_EXTENSIONS=(.mka .ass)
subdub_name_args=()
build_name_filter subdub_name_args suffix "${SUBDUB_EXTENSIONS[@]}"

ALL_EXTENSIONS=("${VIDEO_EXTENSIONS[@]}" "${SUBDUB_EXTENSIONS[@]}")
name_args=()
build_name_filter name_args suffix "${ALL_EXTENSIONS[@]}"

merge_many() {
    if [[ ! "$(realpath "$1")" =~ $BASE_DIR/.*/.* ]]; then
        echo "Inappropriate directory."
        return
    fi
    dir="$(realpath "$1")"
    mkdir -p "${dir/#$BASE_DIR/$OUTPUT_DIR}"
    args_dir=$(mktemp -d 'mergevideo_args.XXXXX')
    mkdir "$args_dir/inputs"
    
    readarray -t basenames < <(find "$1" -maxdepth 1 "${video_name_args[@]}" -printf '%f\n' | \
        sed 's#\..*$##' | \
        fzf -m -0 --prompt "Which episodes to merge? ")
    if [[ "${#basenames[@]}" -eq 0 ]]; then
        return
    fi
    name_filter=()
    build_name_filter name_filter prefix "${basenames[@]}"

    find "$(realpath "$1")" -maxdepth 1 "${video_name_args[@]}" -and "${name_filter[@]}" | sort | sed "s#$BASE_DIR#$OUTPUT_DIR#" > "$args_dir/outputs"
    if [[ "$( (wc -l "$args_dir/outputs" | cut -f1 -d' ') )" -eq 0 ]]; then
        echo "Video files were not found."
        return
    fi

    find "$1" -maxdepth 1 "${video_name_args[@]}" -and "${name_filter[@]}" | sort > "$args_dir/inputs/0"
    i=1
    find "$1" -maxdepth 3 \
        "${subdub_name_args[@]}" -and "${name_filter[@]}" \
        -printf '%h\n' | uniq | sort | while read -r dir; do
        find "$dir" -maxdepth 1 "${name_args[@]}" | sort > "$args_dir/inputs/$i"
        ((i++))
    done 
    readarray -t input_idx < <(find "$args_dir/inputs" -type f -printf "%P\n" | sort -n)
    if [[ "${#input_idx[@]}" -lt 2 ]]; then
        echo "External sub and dub files were not found."
        return
    fi
    maps=()
    inputs=()
    input_files=()
    for i in "${input_idx[@]}"; do
        maps+=(-map "$i")
        inputs+=(-i "{$((i+1))}")
        input_files+=('::::+' "$args_dir/inputs/$i")
    done

    parallel --bar ffmpeg -y "${inputs[@]}" -c copy "${maps[@]}" "{$((${#input_idx[@]}+1))}" "${input_files[@]}" ::::+ "$args_dir/outputs"
    rm -rf "$args_dir"
}

merge_many "$1"
